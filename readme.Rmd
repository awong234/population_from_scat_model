---
title: "Scat Counting Simulation"
author: "Alec Wong"
date: "February 19, 2018"
output:
  html_document:
    keep_md: yes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, comment = NULL)

source('functions.R')

library(ggplot2)
library(dplyr)
library(foreach)
library(broom)
library(tidyr)
library(rgdal)

options(digits = 3)
```

# Overview

The major components of this simulation are as follows:

* Simulate a population of scats with a rate of deposition, to estimate the population based on simulated collections.
* Simulate collection of scats by probabilistically drawing Bernoulli samples based upon dog tracks within the grid cell coincident with the scat.
* Estimate scat deposition rate per visit using a modified N-mixture model that incorporates scat 'recruitment' and 'survival', where 'recruitment' is a rate of deposition, and 'survival' is fixed to 0, since all scats encountered are immediately removed.

# Simulating the data

## Dog tracks

I obtained two example dog tracks from 2017 to examine and test under this framework. The sites referenced are 12B2, and 15A4, during three consecutive visits within mid-July to August. 

The site 12B2 exhibited extremely high moose density, and thus the dog movement is no doubt affected heavily by this. In the case that this movement -- being unexplained in the model we're using -- affects model performance, the other site 15A4 was selected to be tested as well. This site exhibited no moose collections throughout the summer, and the dog movement is taken to be the most 'natural' search pattern under normal conditions. 15A4 is also relatively easy terrain, so the dogs' movement was not inhibited by thorns, slope, water, or the like.

### Examples

```{r dogExample, echo = F, message = F, warning = F, error = F, include = F}

sites = c(rep("12B2",3), rep("15A4", 3))

out = getGPX() #loads gpx files

allPoints = convertPoints() #takes gpx files and converts to a complete dataset with points, dates, sites, and 'rounds'

# Scale individual transect points. Obtain scaling parameters.

# scaled_12B2 = allPoints %>% as.data.frame() %>% filter(Site == "12B2") %>% select(Easting, Northing) %>% scale
# scaled_15A4 = allPoints %>% as.data.frame() %>% filter(Site == "15A4") %>% select(Easting, Northing) %>% scale
# 
# scaled_12B2_center = attr(x = scaled_12B2, which = 'scaled:center')
# scaled_12B2_scale = attr(x = scaled_12B2, which = 'scaled:scale')
# 
# scaled_15A4_center = attr(x = scaled_15A4, which = 'scaled:center')
# scaled_15A4_scale = attr(x = scaled_15A4, which = 'scaled:scale')
# 
# allPoints@coords[allPoints@data$Site == "12B2"] = scaled_12B2
# allPoints@coords[allPoints@data$Site == "15A4"] = scaled_15A4
# 
# meanScale = scaled_12B2_scale %>% bind_rows(scaled_15A4_scale) %>% colMeans

xlim = c(-3,3)
ylim = c(-2,2)

# Generate grid

scaledData = getScaledData(transectPoints = allPoints)

scaledGrid = scaledData$scaledGrid
scaledTracks = scaledData$scaledTracks

bbox_scaled = getBbox(scaledGrid %>% select(Easting, Northing))

for(r in 1:3){
# Cairo::Cairo(width = 1920, height = 1080, dpi = 150, file = paste0("path",r,".png"))  
#   print(
    # ggplot() +
    # geom_tile(data = scaledGrid, aes(x = Easting, y = Northing), fill = 'white', color = 'black') +
    # geom_path(data = scaledTracks %>% as.data.frame() %>% filter(Round == r), aes(x = Easting, y = Northing, color = Site, linetype = Round)) +
    # guides(color = guide_legend(order = 1), linetype = guide_legend(order = 2)) +
    # coord_cartesian(xlim = xlim, ylim = ylim) + coord_map()
#   )
# dev.off()
}

```

![](readme_files/dogTrack.gif)

In the figure above, we see two triangular transects, and notice that multiple 'Rounds' or visits are made to each site, depicted in the image. They are centered such that the centroid of the transects are on 0, but independently scaled so that the transects are the same size relative to each other. The grid was first generated to be 50m x 50m, and then scaled by the same amount. To easily verify the grid size, count the squares covering the vertical portion of 12B2; they number 20, indicating that the length of the side is approximately 1km, which is true.

I scaled and centered the dog tracks so that they may sample the same population of scats, to observe any differences in estimates. Notice that 12B2 is more 'wiggly', owing to the frequency of moose scat encounters.

# Simulation of scat deposition and encounters

The deposition of scats is to be done in a Poisson random fashion, with additional 'recruitment' being added with some rate $\theta$. 

Validation requires knowledge of where the scats were generated, where dog tracks intersect the scats' grid cells, and whether they are being removed properly. 

## Scat simulation

This part is easy enough. I test using an initial deposition of 500 uniformly distributed scat piles. 

```{r scatPlot}


set.seed(1)

scats_init = 500

maxR = 3

scatXY = cbind.data.frame(ID = 1:scats_init,
                          x = runif(n = scats_init, min = bbox_scaled[1,1], max = bbox_scaled[1,2]),
                          y = runif(n = scats_init, min = bbox_scaled[2,1], max = bbox_scaled[2,2]),
                          RoundDeposited = factor(x = 0, levels = c(0:maxR)), pEnc = 0, Removed = factor(x = 0, levels = c(0,1)))

gridX = scaledGrid %>% pull(Easting) %>% unique %>% sort
gridY = scaledGrid %>% pull(Northing) %>% unique %>% sort


scatsGridRef = refPointsToGrid(queryPoints = scatXY %>% select(x,y), gridPoints = scaledGrid %>% select(Easting, Northing))

scatXY = addGridID_to_Points(queryPoints = scatXY, refPointsToGrid_Output = scatsGridRef, gridLayer = scaledGrid)

d = countPointsInGrid(queryPoints = scatXY %>% select(x,y), gridPoints = scaledGrid %>% select(Easting, Northing))

ggplot() + 
  geom_tile(data = scaledGrid, aes(x = Easting, y = Northing), fill = 'white', color = 'black') + 
  geom_text(data = d, aes(x = gridX[x], y = gridY[y], label = Freq), size = 2) + 
  # geom_path(data = allPoints %>% as.data.frame(), aes(x = Easting, y = Northing, color = RoundBySite)) + 
  geom_point(data = scatXY, aes(x = x, y = y), shape = 3, color = 'red') + 
  coord_cartesian(xlim = c(1,1), ylim = c(1,1))
  
```

In the above plot, we have scat locations (red '+'), and grid cells with numbers marking how many scat piles exist within the grid. The function written to count any given point layer within grid cells is working properly - it is zoomed in to demonstrate this, but is correct for the wider grid on the whole. 

## Dog track points within grid

I also need to verify that I'm detecting any dog track within the grids. Below, I test a function generating a probability of detection based on track length within a grid, or based on some baseline probability of detection, but for validation I am using detection == 1.

```{r scatDeposPlot, out.height=1080, out.width=1920, dpi = 150}

set.seed(1)

scats_init = 500

maxR = 3

scatXY = cbind.data.frame(ID = 1:scats_init,
                          x = runif(n = scats_init, min = bbox_scaled[1,1], max = bbox_scaled[1,2]),
                          y = runif(n = scats_init, min = bbox_scaled[2,1], max = bbox_scaled[2,2]),
                          RoundDeposited = factor(x = 0, levels = c(0:maxR)), pEnc = 0, Removed = factor(x = 0, levels = c(0,1)),
                          RoundRemoved = factor(x = NA, levels = c(1:maxR)))

gridX = scaledGrid %>% pull(Easting) %>% unique %>% sort
gridY = scaledGrid %>% pull(Northing) %>% unique %>% sort


scatsGridRef = refPointsToGrid(queryPoints = scatXY %>% select(x,y), gridPoints = scaledGrid %>% select(Easting, Northing))

scatXY = addGridID_to_Points(queryPoints = scatXY, refPointsToGrid_Output = scatsGridRef, gridLayer = scaledGrid)

recruit_rate = 200

siteToTest = "12B2"

gridLayer = scaledGrid

scatXY.rec = list(scatXY)

for(r in 1:maxR){
    
    siteTrackPoints = scaledTracks %>% as.data.frame %>% filter(Site == siteToTest, Round == r)
    
    gridsVisited = countPointsInGrid(queryPoints = siteTrackPoints, gridPoints = gridLayer %>% select(Easting, Northing)) %>% filter(Freq > 0)
    
    gridsVisitedID = cbind(x = gridX[gridsVisited$x], y = gridY[gridsVisited$y]) %>% as.data.frame %>% left_join(y = gridLayer, by = c("x" = "Easting", "y" = "Northing"))
    
    scatsAvail = scatXY %>% filter(Removed == 0, gridID %in% gridsVisitedID$ID)
    
    # To add later: a metric for encounter probability that models time and distance searched. For now, set as 1.
    scatsAvail$pEnc = 1 #later, some probability model ~ time, distance
    
    scatXY[scatXY$ID %in% scatsAvail$ID,"pEnc"] = 1
    
    # Simulate encounters. All scats encountered will be removed.
    scatXY[scatXY$ID %in% scatsAvail$ID,"Removed"] = rbinom(n = 1, size = 1, prob = scatsAvail$pEnc)
    scatXY = scatXY %>% mutate(RoundRemoved = ifelse(test = {ID %in% scatsAvail$ID & Removed == 1}, yes = r, no = RoundRemoved))
    
    # Cairo::Cairo(width = 1920, height = 1080, file = paste0('removPlot',r,'.png'), dpi = 150)
    #   print(
    #     ggplot() +
    #     geom_tile(data = gridLayer, aes(x = Easting, y = Northing), fill = 'white', color = 'black') +
    #     # geom_text(data = gridLayer, aes(x = Easting, y = Northing, label = ID)) +
    #     geom_path(data = siteTrackPoints, aes(x = Easting, y = Northing)) +
    #     geom_point(data = scatXY, aes(x = x, y = y, shape = Removed, color = RoundDeposited, size = Removed)) + 
    #     guides(color = guide_legend(order = 1), shape = guide_legend(order = 2)) + 
    #     scale_color_manual(values = c('red', 'forestgreen', 'blue')) + 
    #     scale_shape_manual(values = c(1,4)) + 
    #     scale_size_manual(values = c(1,3), guide = F) + 
    #     ggtitle(paste("Current Round:", r))
    #   )
    # dev.off()
    
    # Simulate new scat deposition; no need on last round. 
    
    if(r < maxR){ 
      
      newScatN = rpois(n = 1, lambda = recruit_rate)
      
      if(r == 1) {
        depositionLog = vector(mode = 'integer', length = maxR+1)
        depositionLog[1] = scats_init
        depositionLog[2] = newScatN
      }
      
      depositionLog[r+1] = newScatN
      
      lastID = scatXY$ID[nrow(scatXY)]
      
      scatXY = scatXY %>% bind_rows(data.frame(ID = (lastID+1):(lastID+newScatN), 
                                               x = runif(n = newScatN, min = bbox_scaled[1,1], max = bbox_scaled[1,2]),
                                               y = runif(n = newScatN, min = bbox_scaled[2,1], max = bbox_scaled[2,2]),
                                               RoundDeposited = factor(r, levels = c(0:maxR)), pEnc = 0, Removed = factor(0, levels = c(0,1))))
      
      scatsGridRef = refPointsToGrid(queryPoints = scatXY %>% select(x,y), gridPoints = gridLayer %>% select(Easting, Northing))
      
      scatXY = addGridID_to_Points(queryPoints = scatXY, refPointsToGrid_Output = scatsGridRef, gridLayer = gridLayer)
      
    }
    
    
    
    # Validate grid id's
    
    # Cairo::Cairo(width = 1920, height = 1080, file = paste0('gridIDplot',r,'.png'), dpi = 150)
    # print(
    #   ggplot() +
    #     geom_tile(data = gridLayer, aes(x = Easting, y = Northing), fill = 'white', color = 'black') +
    #     geom_text(data = gridLayer, aes(x = Easting, y = Northing, label = ID)) +
    #     geom_path(data = siteTrackPoints, aes(x = Easting, y = Northing)) +
    #     geom_point(data = scatXY, aes(x = x, y = y, shape = Removed, color = RoundDeposited), size = 5) + 
    #     scale_shape_manual(values = c(1,4))
    # )
    # dev.off()
    
    
    
    # Need a record of WHEN scats encountered. These are snapshots of the scat data from round to round.
    
    scatXY.rec[[r+1]] = scatXY
    
  }
  
  names(scatXY.rec) = paste("Round", 0:maxR)
  
  toReturn = list("ScatRecords" = scatXY.rec, "DepositionRecords" = depositionLog)
  

    
```

![](readme_files/scatDeposPlot.gif)

In the plot above, we see 500 initial scats deposited, followed by a random number of scats deposited afterward modeled as Poisson with mean = `r recruit_rate`. Since they are not reproducing in the normal sense, the recruitment rate is independent of the scat population size[^1]. 

[^1]: However, the recruitment rate might be related to the initial size deposited, since they both indicate more moose on the transect.

We observe a series of `r paste0(depositionLog[1:3])` scats deposited in the initial sample, after the first sample, and after the second sample, respectively. Of course, there is no sampling after the third sample, so that recruitment is not simulated.

In the following plot, pay particular attention to the highlighted areas:

![](readme_files/scatDeposPlot2.gif)

Those scats are changing their status from 'not removed', to 'removed', demonstrating the function's proper operation. They are deposited amongst the initial sample, and on the first visit the dog track does not intersect their grid cell, and so they are not removed in the first round. In the second round, notice that the dog track intersects their grid cell, and so they are removed[^2].

[^2]: The simulation has p(detect) = 1 if there is any track within the grid whatsoever. Later, we can adjust to make it a function of distance traveled, area covered, time, or a combination of these.

## Dataset obtained

The simulated dataset is obtained by filtering out only those scats that were removed (since we would not have information about those not removed), as below:

```{r, eval = T}

knitr::kable(x = scatXY.rec[[3]] %>% filter(Removed == 1)%>% slice(1:10), align = 'cccccccc', digits = 2) 

```

<br />


Let's look at individual 41. The scat was deposited in round 0, but wasn't removed until round 2 - we shall see if this is correct.

```{r, eval = F}

for(r in 1:3){
  siteTrackPoints = scaledTracks %>% as.data.frame %>% filter(Site == siteToTest, Round == r)
  scatDat = scatXY.rec[[r+1]] %>% filter(ID == 41)
  shapes = c(1,4,4)
  
  labels = c("Available", "Removed", "Removed")

# Cairo::Cairo(width = 1920, height = 1080, file = paste0('indScatPlot',r,'.png'), dpi = 150)
# print(
  ggplot() +
  geom_tile(data = gridLayer, aes(x = Easting, y = Northing), fill = 'white', color = 'black') +
  # geom_text(data = gridLayer, aes(x = Easting, y = Northing, label = ID)) +
  geom_path(data = siteTrackPoints, aes(x = Easting, y = Northing)) +
  geom_point(data = scatDat, aes(x = x, y = y, shape = Removed), color = 'red') +
  scale_shape_manual(values = shapes[r]) +
  geom_text(aes(x = 1, y = -0.3), label = paste0("Round ", r, ": ", labels[r]))
  
# )
# dev.off()

}

```

![](readme_files/indScatGIF.gif)

In the above plot, notice that this particular scat pile is not encountered in the first occasion, due to the lack of any track points in its grid cell. In the second occasion, it is encountered due to the change in the dog track pattern directing it into the grid cell of the scat.

## Incorporating detection probability

### Indicator model

Simulation of detection probability in the 'indicator' fashion proceeds as follows:

$$
p(\text{detect}) = p_0 * I(\text{track in grid})
$$

where $I$ is the indicator function evaluating to 1 if there exists any track within the grid, and 0 if there does not. 

A Bernoulli trial is applied to each scat, simulating its encounter (and removal). Since dogs appear to be extremely discerning when it comes to detecting scats, I test using a detection probability of 0.8, but any value can be simulated.

### Length model

In future revisions, a scat's detection probability will be determined by the length of track in the grid cell that the scat occupies, in this fashion:

$$
p(\text{detect}) = p_0 * \sum_{i=1}^{I-1} \text{dist}(x_{i+1},x_i)
$$

where, $\text{dist}(x_i,x_j)$ is the euclidean distance between points $x_i$ and $x_j$. If there exists no dog track points in the grid cell, the probability of detection is zero. If by chance there is a singular point represented in a grid cell, instead of assigning it an arbitrary distance I will consider it with distance 0, and as such equivalent to no track length within the grid.

## Observation of detection process

### Indicator process

I identify a series of scats that were deposited in the first round and removed in the last for observation. 

```{r ID_scats}

recruit_rate = 200

scatSim = simScats(transectPoints = scaledTracks, gridLayer = scaledGrid, scats_init = 500, recruit_rate = recruit_rate, maxR = 3, debug = F, seed = 1, siteToTest = "12B2", probForm = 'indicator', p0 = 0.8)

ID1 = scatSim$ScatRecords$`Round 3` %>% filter(RoundDeposited == 0, RoundRemoved == 3) %>% pull(ID) #Those scats deposited in initial deposition, and removed in final round. 

knitr::kable(scatSim$ScatRecords$`Round 3` %>% filter(RoundDeposited == 0, RoundRemoved == 3), digits = 2)
```


#### Example: Individual 66

Observe individual 66:

```{r ID66}

ID66 = bind_rows(scatSim$ScatRecords) %>% filter(ID == 66)

rownames(ID66) = paste("Round", 0:maxR, " Snapshot")

knitr::kable(ID66)

```

Evidently, the probability of encounter was 0 until the final occasion, meaning that we ought to observe no track until round 3. 

```{r plot66, eval = F} 

# observe ind 66

for(r in 1:3){
  siteTrackPoints = scaledTracks %>% as.data.frame %>% filter(Site == siteToTest, Round == r)
  scatDat = scatSim$ScatRecords[[r+1]] %>% filter(ID == 66)
  shapes = c(1,1,4)
  
  labels = c("Available", "Available", "Removed")

Cairo::Cairo(width = 1920, height = 1080, file = paste0('indScatPlot',r,'.png'), dpi = 150)
print(
  ggplot() +
  geom_tile(data = gridLayer, aes(x = Easting, y = Northing), fill = 'white', color = 'black') +
  # geom_text(data = gridLayer, aes(x = Easting, y = Northing, label = ID)) +
  geom_path(data = siteTrackPoints, aes(x = Easting, y = Northing)) +
  geom_point(data = scatDat, aes(x = x, y = y, shape = Removed), color = 'red') +
  scale_shape_manual(values = shapes[r]) +
  geom_text(aes(x = 1, y = -0.3), label = paste0("Round ", r, ": ", labels[r]))
  
)
dev.off()

}

```

![](readme_files/ind66.gif)

In the above plot, we do indeed see no track until round 3. 

Another way to look at the data is to see whether -- in any round -- given track in grid, about 80% of those scats should be removed. Let's observe:

```{r propRemoved, echo = T}

# Of those with p(encounter) > 0, how many removed?
table1 = scatSim$ScatRecords$`Round 1` %>% filter(pEnc > 0) %>% {summary(.$Removed)} 
names(table1) = c("Not Removed", "Removed")
print(table1)
```

We see that `r table1[2]` individuals of `r sum(table1)` individuals are removed in Round 1: this is approximately 80%, or more specifically, `r table1[2]/sum(table1)` %.

# Data structure

The data obtained are a record of collections per grid, per visit. Below, I randomly sample a few records from each visit to show the counts.

```{r scatData, comment = NULL}
dataObtained = scatSim$ScatRecords$`Round 3` %>% filter(Removed == 1)

dataObtained %>% mutate(gridID = factor(gridID, levels = scaledGrid$ID), RoundRemoved = factor(RoundRemoved)) %>% group_by(RoundRemoved, gridID) %>% tally %>% group_by(RoundRemoved) %>% sample_n(5) 

```

Of course, we must complete the data with counts of 0 at those grids that we did visit. To do this, we pull the grid ID's from the set of all grids visited (recorded during the simulation as having track points > 0 within a grid), and then use the `complete()` function from `tidyr` to fill in the 0 counts for those grids missing from the dataset above. The data are then spread into wide format using the `spread()` function from `tidyr`.

```{r, scatDataWide, comment = NULL, warning=FALSE}
# All grids ever visited.
gridsVisited = scatSim$GridVisitsRecords %>% bind_rows %>% pull(ID) %>% unique %>% sort

# Which grids among the total were visited, per round? 
vis = lapply(X = scatSim$GridVisitsRecords, FUN = function(x){gridsVisited %in% x$ID}) %>% do.call(what = cbind, args = .) %>% cbind(F, .)
vis = vis*1 # Convert to integer
rownames(vis) = as.character(gridsVisited)

# Indexed.
gridsIndex = as.integer(gridsVisited %>% as.factor)
names(gridsIndex) = as.character(gridsVisited)

# Number of sites ever visited.
nSites = length(gridsIndex)

# Number of VISITS
maxR = 3

# Number of occasions INCLUDING original deposition
maxT = maxR + 1

# Format data properly. We need counts at each site (gridID). We need to preserve 0 counts. 
# We also need sites visited in each round.



getCounts <- function() { # quick, no need for formal arguments, just avoiding side-effects.
  
  counts = list()

  for(r in 1:length(scatSim$GridVisitsRecords)){
    
    gridsVisited = scatSim$GridVisitsRecords[[r]]
    
    counts[[r]] = dataObtained %>% filter(RoundRemoved == r) %>% mutate(gridID = factor(gridID, levels = gridsVisited$ID)) %>% group_by(gridID) %>% 
      summarize(count = n()) %>% complete(gridID, fill = list(count = 0))
    
  }
  
  return(counts)
  
}

counts = getCounts()

counts_long = bind_rows(counts) %>% mutate(Round = rep(1:length(counts), sapply(X = counts, FUN = function(x){nrow(x)}))) %>% mutate(gridID = as.integer(gridID))

# Check to see visits are right. They are.

counts_xy = lapply(counts, FUN = function(x){x %>% left_join(scaledGrid %>% mutate(ID = factor(ID)), by = c("gridID" = "ID"))}) # Obtain grid centers in data

# NA's show when sites not visited
counts_wide = spread(counts_long, key = Round, value = count) %>% arrange(gridID)
counts_wide = cbind('gridID' = counts_wide$gridID, `0` = NA, counts_wide[,2:4])

# NA's don't go into jags though, that's what `vis` is for; to indicate which sites were visited. y will be counts only.
y = counts_wide[,2:5]
y[is.na(y)] = 0

print(counts_wide[1:20,])
print("...")
```
In the above dataset, I've truncated the first 20 rows for visibility. NA's exist where the site was *not* visited during each round (integer column names), and rows with all 0's exist, indicating grid cells where no counts were made, but were visited. The data are easily checked against the following plot for visual confirmation:

![](readme_files/scatCounts.gif)

To prepare these data for the JAGS analysis, the NA's in the count dataset are converted to 0's, and a separate matrix is formed that is binary with 1's indicating a visited site, and 0's indicating a non-visited site, of the same dimension as the wide data. For instance, that indicator matrix appears as follows:

```{r, vis}

vis[1:30,]

```

Again, the data are truncated for visibility. 

# Model Definition

The general idea here is that we have repeated counts of a population of individuals, which are usually modeled in the "N-mixture" fashion developed by Royle 2004, and extended for open populations by Dail and Madsen 2011. 

At any given site, the observations are modeled as binomial, with the structure

$$
y_{it} \sim \text{Bin}(N_{it},p)
$$
with $y_{it}$ being the observed counts at site $i$, on occasion $t$, $N_{it}$ being the total population available for sampling at site $i$ on occasion $t$, and $p$ the detection probability. 

Where we depart from the models of Dail and Madsen is that we model differently the population. Instead of the sum of the densities of the random variables for survival $S_{it}$ and recruitment $G_{it}$, we need not model survival if we make the assumption that the 'dying' individuals are only those we collect; analogous to perfect knowledge of 'survival'. However, we retain the basic Poisson structure for recruitment, and I relabel this $R$.

In our model here, I choose to analyze the process as follows:

|          |      Round 0    |      Round 1     |     Round 2     |     Round 3     |
| -------- | :--------------:| :-------------:  | :-------------: | :-------------: |
| N status |      $N_0$      | $N_0 + R_1 - y_1$|$N_1 + R_2 - y_2$|  $N_2+R_3-y_3$  |

In this fashion, the sums above represent the final abundance of individual scats among the observed grid cells *after* all events of collection and recruitment have occurred. The implication of this is that the counts $y_{it}$ are conditional on the sum $N_{t-1}$ as defined above. The model is as follows:

\begin{gather}
y_{it} \sim \text{Bin}(N_{i,t-1}, p_{it})\\
N_{it} = N_{i, t-1} + R_{it} - y_{it}\\
N_{i0} \sim \text{Poisson}(\lambda)\\
R_{it} \sim \text{Poisson}(\theta) ; t > 0\\
\end{gather}

The parameters to estimate are thus $\lambda$, $\theta$, and $p_{it}$. I model $p_{it}$ as homogeneous with all entries equal to $p_{00}$ which has the uninformative prior $p_{00} \sim \text{Uniform}(0,1)$. $\lambda$ is the exponent of a normal prior $\beta_0 \sim \text{Norm}(0, 0.01)$, and $\theta$ has a prior $\theta \sim \text{Uniform}(0,100)$. 


# Truth data 

I have not modeled density, so each of these are outcomes of the random variables *per grid*. There are `r nrow(scaledGrid)` total grid cells, and we sample a total of `r gridsVisited %>% length` cells; that is a proportion of `r (gridsVisited %>% length)/nrow(scaledGrid)`. The population size among the grid cells we visit in total is as follows:

```{r, trueN}
scatSim$ScatRecords$`Round 3` %>% filter(gridID %in% gridsVisited) %>% nrow
```

In each round, the population size available to be sampled is:

```{r, trueNperRound}

gridsVisitedperRound = sapply(X = scatSim$GridVisitsRecords, FUN = function(x){x$ID})

popAvail = c(0,
  scatSim$ScatRecords[[1]] %>% filter(Removed == 0, gridID %in% gridsVisitedperRound[[1]]) %>% nrow,
  scatSim$ScatRecords[[2]] %>% filter(Removed == 0, gridID %in% gridsVisitedperRound[[2]]) %>% nrow,
  scatSim$ScatRecords[[3]] %>% filter(Removed == 0, gridID %in% gridsVisitedperRound[[3]]) %>% nrow
)



names(popAvail) = paste("Round", 0:3)

print(popAvail)
```
These numbers are drawn from the full simulated dataset conditional on whether the grids were visited, and the scats were not removed yet. The interpretation is, for example "In Round 1, 65 scats were left over from Round 0, and were available for encounter". Again, the population 'left over' is the sum of the population available to be sampled, plus the recruits, minus the observed individuals. Note that since Round 0 is the initial deposition period, there is no recruitment between then and the first visit, since we assume whatever happened prior to our first visit is subsumed in the model for $N_{i0}$.

We made the following observations:

```{r, countsPerRound}
countSums = colSums(counts_wide, na.rm=T)[2:5]
names(countSums) = paste("Round", 0:3)
print(countSums)
```

Per round, the proportions taken are:

```{r, propsPerRound}
(countSums/popAvail)
```

with mean approximately `r ((countSums/popAvail) %>% mean(na.rm = T))*100`%. Note that the sum of these time-specific available population sizes is NOT the total population size, due to unobserved individuals carried between sessions. 

Our observations thus form approximately `r (colSums(counts_wide, na.rm=T)[2:5] %>% sum /  scatSim$ScatRecords[[3]] %>% filter(gridID %in% gridsVisited) %>% nrow)*100`% of the scats available to be observed, which is how we simulated the process.

The recruitment rate $\theta$ was approximately `r scatSim$DepositionRecords[2]/nrow(scaledGrid)`.

The initial expected population size per grid $\lambda$ was approximately `r scatSim$DepositionRecords[1]/nrow(scaledGrid)`.

# Analysis in JAGS

The data were input into JAGS under the model defined as 'model.txt' in the parent directory of this repository. One million iterations were run with four chains, and half of these were discarded as burn-in. I selected one million iterations due to the results observed experimenting with smaller iteration sizes; often, the estimates of N were overestimated by periodic sampling of the parameters $\lambda$ and $\theta$ in extremes of the state space. When 50,000 iterations proved too small, I selected one million since the analysis time is relatively short.

To keep the dimensions of the visited sites constant, I used an indicator variable `vis[i,t]` multiplied against $p_0$ to fix the probability of encounter at unvisited sites to 0. 

The initializer function provided appears as follows:

```{r, eval = F, echo = T}
inits = function(){list(p0 = cbind(rep(NA,nSites), matrix(data = 0.8, nrow = nSites, ncol = maxR)), 
                        R = cbind(rep(NA,nSites), matrix(data = 1, nrow = nSites, ncol = maxR)),
                        N1 = rowSums(y))}
```

I initialized p0 to be the correct value, R to be relatively small, and most importantly, I initialized the first population size at all sites to be the `rowSums` of $y_{it}$. For there to be no conflicting parent values, the starting population must be *at least* as large as the observed counts, and we certainly cannot have an initial value of 0 where we have non-zero observations. 

Since we fix the first column (time 0, or initial deposition period) of $p_0$ and $R$ to be 0 within the model script, those retain NA values in the initializing function.  

## Analysis summary

A summary of the analysis follows:

```{r, jagsOut}
library(jagsUI)
if(!exists("jagsOut")){load('oneMilTest.Rdata')}
summary(jagsOut)
```

Observe that all of the estimates are within coverage except for `N_time[3]`, and `theta`. 

Also note that `N_time[1]` refers to $N_0$, and `N_time[4]` would refer to $N_3$, the population size resulting after recruitment and sampling on the third occasion. This number is of no importance to us, since we did not sample a fourth occasion. 

The model appears to be running, albeit with some biased estimates. I expect that perhaps this may be due to relatively small sample size per grid cell, or perhaps a random outcome of the simulation. More simulations should be done to validate this model.

### Footnotes