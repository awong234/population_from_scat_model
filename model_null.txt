# Will probably have to restructure.
# Every 'site' will be a unique grid cell i. 
# Every round t from 0 to maxT. 
# Every visit v from 1 to maxV. THIS NEEDS TO BE REFERENCED PROPERLY WHEN CALCULATING THE MECHANISM OF N, y, and R!!!!!!

# N should be allowed to vary by a covariate on Moose Transect.

# theta should be allowed to vary by a covariate of Moose Transect and a spatial covariate. Ideally, it should be dependent upon days between visits. R[i,t] = dpois(theta[i] + beta1_MooseTEffect[MT] + beta2_)

# Estimate # moose within model. It will be calculated as (All deposition of scats after clearing) = ((theta[i]*tot_days / per_moose_daily_deposition[i]*tot_days[i]) = theta[i] / per_moose_daily_deposition)

# The above is the total daily deposition rate divided by some assumed per-moose daily deposition rate.

# per_moose_deposition as a fixed effect will be a mean daily deposition rate. Or maybe estimate a random variable with a prior based on literature info.

model
{
    # Priors
    p00 ~ dunif(0,1)
    theta0 ~ dnorm(0,0.01) #prior for theta intercept
    beta0 ~ dnorm(0,0.01) #prior for lambda intercept
    beta_site ~ dnorm(0,0.01) #prior for Moose Transect intercept
    beta_space ~ dnorm(0,0.01) #prior for habitat covariate
    
    # Time 1 is visit 1, but indexed by 2, since we need to model the initial N. I choose to call that period before any visits time 0.
    lambda = exp(beta0) # immaterial except for mechanistic model of deposition process and observation.
    theta = exp(theta0) # extend to include moose transect effect, spatial covariate effects. This is deposition per grid cell i, and therefore # moose will be calculated as per grid cell. 
    
    for(i in 1:nSites){

        # Need model for N's
        # This iteration of the model has a slightly different structure for N due to changes in simulation.
        # Before, y_t ~ Bin(N_t-1, p)
        # Now,    y_t ~ Bin(N_t, p)
        
        # First N (in time 0) is Poisson random
        N1[i] ~ dpois(lambda)

        for(v in 1:maxV){
            N[i,1,v] = N1[i]
        }       

        # First recruitment (in time 0) is 0
        R[i,1] = 0

        # First detection in time 0 is 0 (we didn't visit any sites in initial deposition). Unnecessary with vis[,,]
        # p0[i,1,1:2] = 0

        # Proceeding N's add new recruits and remove current counts from the previous time step's N.
        # Recruits are random poisson variates with mean theta.
        # Remember that y[i,t] is the t-1 visit, so it makes sense that N_t should be dependent upon what was found in the previous visit.
        for(t in 2:maxT){
            R[i,t] ~ dpois(theta) # Every round has some added deposition after we leave. It is dependent upon the DAYS in between visits. Reformat potentially to dpois(theta*days[site,interval])
            N[i,t,1] = N[i,t-1,2] - y[i,t-1,2] + R[i,t-1] # First time going to a sampling unit what's there is what was there last time, minus what we picked up last time, plus what deposition happened last time.
            N[i,t,2] = N[i,t,1] - y[i,t,1] # Second visit to a sampling unit what's there is what was there after the first visit, minus what we picked up. 
        }
        
        # Observation likelihood. Counts are conditional on population size at previous time step (after recruits and removals), and detection (which also depends on having visited the site).
        for(t in 2:maxT){ 
            for(v in 1:maxV){

                # Homogeneous detection
                p0[i,t,v] = p00

                # adjust p0 such that those sites not visited are set to 0. Initially, all sites are p0[i,t] = 0.8
                # vis is a matrix of binary indicators with '1' being 'visited', and '0' being 'not visited'. Multiply by p0 to fix 'not visited' sites to p = 0, and obtain a new matrix.
                p[i,t,v] = p0[i,t,v] * vis[i,t,v]

                y[i,t,v] ~ dbin(p[i,t,v], N[i,t,v])

            }            
        }        

    }

    for(t in 1:maxT){
            N_time[t] = sum(N[,t,1]) # Don't really care about this too much.
        }

    # N_moose[i] = theta[i] / per_moose_deposition # something like this

}